# 2654. 使数组所有元素变成 1 的最少操作次数

## 题目描述

给你一个下标从 0 开始的正整数数组 `nums`。你可以对数组执行以下操作任意次数：

- 选择一个满足 `0 <= i < n - 1` 的下标 `i`，将 `nums[i]` 或者 `nums[i+1]` 之一替换为它们的最大公约数。

返回使数组所有元素都变成 `1` 的 最少操作次数。如果无法使数组所有元素都变成 `1`，返回 `-1`。

两个数的最大公约数是能整除这两个数的最大整数。

## 示例

**示例 1：**
```
输入：nums = [2,6,3,4]
输出：4
解释：执行以下操作可以使数组所有元素都变成 1：
- 选择 i = 2，将 nums[3] 替换为 gcd(3,4) = 1，数组变为 [2,6,3,1]
- 选择 i = 1，将 nums[2] 替换为 gcd(6,3) = 3，数组变为 [2,3,3,1]
- 选择 i = 0，将 nums[1] 替换为 gcd(2,3) = 1，数组变为 [1,3,3,1]
- 选择 i = 1，将 nums[2] 替换为 gcd(3,1) = 1，数组变为 [1,1,3,1]
- 选择 i = 2，将 nums[3] 替换为 gcd(3,1) = 1，数组变为 [1,1,1,1]
```

**示例 2：**
```
输入：nums = [2,10,3,9,6]
输出：5
```

**示例 3：**
```
输入：nums = [1,1,1,1]
输出：0
```

## 提示

- `2 <= nums.length <= 50`
- `1 <= nums[i] <= 10^6`

## 解题思路

1. **如果数组中已经有 1：**
   - 由于 1 和任何数的最大公约数都是 1，我们可以用这些 1 来"感染"相邻的数
   - 操作次数 = 数组长度 - 1 的个数

2. **如果数组中没有 1：**
   - 首先检查整个数组的最大公约数，如果大于 1，说明无法得到 1，返回 -1
   - 否则，需要找到最短的子数组，使其最大公约数为 1
   - 设这个最短子数组长度为 k，则需要 k-1 次操作得到一个 1
   - 然后用这个 1 传播到整个数组，需要 n-1 次操作
   - 总操作次数 = (k-1) + (n-1) = n + k - 2

3. **寻找最短子数组：**
   - 枚举所有可能的子数组，计算其最大公约数
   - 找出最大公约数为 1 的最短子数组
# 贪心算法套路解析

## 如何识别贪心算法问题

贪心算法通常具有以下特征：

1. **最优子结构**：问题的最优解包含子问题的最优解
2. **贪心选择性质**：局部最优选择能导致全局最优解
3. **无后效性**：当前的选择不会影响后续的选择
4. **交换论证**：可以通过交换论证证明贪心选择的正确性

## 贪心算法通用模板

```go
func greedySolution(input) int {
    result := 0
    state := initializeState() // 初始化状态
    
    for !isFinished(input, state) {
        // 1. 找到当前状态下最优的选择
        choice := findBestChoice(input, state)
        
        // 2. 更新状态和结果
        result += calculateContribution(choice, state)
        state = updateState(state, choice)
    }
    
    return result
}

// 核心函数：
// - initializeState(): 初始化状态变量
// - isFinished(): 判断是否处理完毕
// - findBestChoice(): 找到当前最优选择（贪心关键）
// - calculateContribution(): 计算当前选择的贡献
// - updateState(): 更新状态
```

## 贪心算法常见套路

1. **区间调度**：按结束时间排序，选择结束最早的
2. **背包问题**：按单位价值排序，优先选单位价值高的
3. ** Huffman编码**：每次合并频率最小的两个节点
4. **活动选择**：选择结束时间最早的活动
5. **计数累加**：遇到特定模式就累加计数（如本题）

## 实例分析：3228. 将 1 移动到末尾的最大操作次数

### 核心理解

**一句话理解需求：左边的1都要换到右边去，也就是"10"要变成"01"**

每次操作都是把一个"10"转换成"01"，所以问题就变成了：字符串中总共有多少个这样的转换机会。

这个理解直接告诉我们：从左到右遍历时，每当遇到一个0，如果它前面有1个或多个1，那么这些1都需要依次越过这个0，操作次数就是前面1的个数。

### 题目特征识别

1. **最优子结构**：每个"10"转换点的操作次数独立计算
2. **贪心选择性质**：遇到"10"转换点立即操作是最优的
3. **无后效性**：前面1的操作不会影响后面1的操作
4. **交换论证**：无论先移动哪个1，最终都需要越过相同的0边界

### 应用贪心模板

```go
func maxOperations(s string) int {
    result := 0           // 结果累加器
    ones := 0             // 状态：当前遇到的1的个数
    
    for i := 0; i < len(s); i++ { // 遍历直到结束
        if s[i] == '1' {
            // 遇到1，更新状态
            ones++
        } else if i > 0 && s[i-1] == '1' {
            // 找到"10"模式的结束点（即从1到0的转换）
            // 这是当前最优选择点：左边所有1都需要操作一次来越过这个0
            result += ones
            // 状态保持不变，继续处理后续字符
        }
    }
    
    return result
}
```

### 贪心策略详解

**状态设计**：`ones` 记录当前遇到的1的个数

**最优选择**：每当遇到从1到0的转换（即"10"模式的结束点）时立即操作

**贡献计算**：每个"10"转换点贡献左边所有1的个数

**状态更新**：遇到1时增加计数，遇到"10"转换点时累加结果

### 为什么这个贪心是正确的？

1. **局部最优**：每个1遇到第一个0时立即移动，能获得最多操作机会
2. **全局最优**：所有1都遵循相同策略，总操作次数必然最大
3. **交换论证**：无论先移动哪个1，最终都需要越过相同的0边界

## 总结

识别贪心算法的关键是找到问题的"贪心点"——那个局部最优的选择。一旦找到正确的贪心策略，实现通常都很简单。贪心算法的魅力在于：简单的局部规则能够产生复杂的全局最优解。
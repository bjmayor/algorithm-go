# LeetCode 1015. 可被 K 整除的最小整数 - 数学推导与鸽巢原理

这道题目与其说是一道编程题，不如说是一道纯粹的数学题。它考察了同余运算（Modulo Arithmetic）和鸽巢原理（Pigeonhole Principle）。

## 1. 题目核心问题

我们需要找到一个仅由数字 `1` 组成的整数 `N`（如 1, 11, 111...），使得 `N % K == 0`。我们需要返回这个 `N` 的长度。

## 2. 数学分析

### 2.1 排除不可能的情况

首先，观察仅由 `1` 组成的数字：1, 11, 111, 1111...
这些数字的个位数永远是 `1`。

*   如果 `K` 是偶数（能被 2 整除），那么 `K` 的倍数必定是偶数，个位只能是 0, 2, 4, 6, 8。
*   如果 `K` 是 5 的倍数，那么 `K` 的倍数个位只能是 0 或 5。

因此，如果 `K` 能被 2 或 5 整除（即 `K % 2 == 0` 或 `K % 5 == 0`），那么不可能存在个位是 1 的倍数。直接返回 `-1`。

### 2.2 大数处理与同余运算

题目中 `N` 的长度可能非常大，甚至超过 64 位整数的范围，因此我们不能直接计算 `N`。我们只需要关注 **余数**。

我们定义 $N_i$ 为长度为 $i$ 的全 1 数字。
例如：$N_1 = 1, N_2 = 11, N_3 = 111$。

它们之间存在递推关系：
$$N_{i} = N_{i-1} \times 10 + 1$$

根据同余性质：
$$(a \times b + c) \pmod K = ((a \pmod K) \times b + c) \pmod K$$

我们可以只维护当前的余数 $R_i = N_i \pmod K$：
$$R_i = (R_{i-1} \times 10 + 1) \pmod K$$

初始状态 $R_1 = 1 \pmod K$。

### 2.3 为什么最多循环 K 次？（鸽巢原理）

如果在计算过程中，余数 $R_i$ 变为 0，说明找到了答案，长度为 $i$。
如果一直没找到 0 呢？会不会无限循环？

余数的取值范围是 $[0, K-1]$，共有 $K$ 种可能。
如果我们计算了 $K$ 次，生成了 $K$ 个余数：
1.  如果其中包含 0，则已找到答案。
2.  如果其中不包含 0，那么这 $K$ 个余数分布在 $[1, K-1]$ 这 $K-1$ 个“鸽巢”中。根据**鸽巢原理**，必然有两个余数是相同的。

一旦出现重复的余数，序列就会开始循环，永远不会出现 0（因为如果能出现 0，早在循环之前或循环的第一次就出现了）。

**结论**：如果 `K` 不含因子 2 和 5，我们最多只需要尝试 `K` 次。如果 `K` 次内没有找到 0，则无解（实际上对于互质的情况，一定有解）。

## 3. 算法流程

1.  检查 `K % 2 == 0` 或 `K % 5 == 0`，若是则返回 -1。
2.  初始化余数 `remainder = 0`。
3.  循环 `i` 从 1 到 `K`：
    *   更新余数：`remainder = (remainder * 10 + 1) % K`
    *   如果 `remainder == 0`，返回当前长度 `i`。
4.  如果循环结束仍未找到，返回 -1（理论上这一步不会到达，除非 K 有 2 或 5 的因子）。

## 4. 代码实现 (Go)

```go
func smallestRepunitDivByK(k int) int {
    // 1. 排除 2 和 5 的倍数
    if k%2 == 0 || k%5 == 0 {
        return -1
    }

    // 2. 模拟除法过程
    remainder := 0
    for i := 1; i <= k; i++ {
        remainder = (remainder*10 + 1) % k
        if remainder == 0 {
            return i
        }
    }

    return -1
}
```

## 5. 复杂度分析

*   **时间复杂度**: $O(K)$。最坏情况下我们需要循环 $K$ 次。
*   **空间复杂度**: $O(1)$。只需要存储当前的余数。


1. 从 i->j 暴力枚举。 o(n^2)

2. 动态规划。记sumall[i]  为包含i的 子数组最大和。
那么当扩展到i+1, 时，sumall[i+1] = max(nums[i+1],sumall[i]+nums[i+1])
   
3. 有个技巧。如果数组中有正数，那么子序列一定包含正数。
否则就是遍历 比较每一个负数。
   
   
4. 分治法。
关键和合并。
   [p,q] [q+1, m]
   
只有3种情况：
1. [p,q] 的解
2. [q+1,m] 的解
3. 包含q和q+1 的解。

所以需要辅助数据结构，
存下
1. 子数组的和
2. 包含左边界的解
3. 包含右边界的解
4. 解
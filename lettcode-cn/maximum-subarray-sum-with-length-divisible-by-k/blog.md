# 前缀和套路详解：从暴力到优化

## 一、什么是前缀和？

前缀和是处理**区间求和**问题的经典技巧。核心思想很简单：

- 定义 `sum[i]` 为数组前 i 个元素的和
- 那么区间 `[i, j]` 的和就是：`sum[j] - sum[i-1]`

这样可以将 O(n) 的区间求和降到 O(1)。

## 二、以 LeetCode 3381 为例

### 题目回顾

> 给定数组 `nums` 和整数 `k`，求长度能被 k 整除的子数组的最大和。

### 思路演进

#### 第一步：识别前缀和场景

看到**子数组的和**，第一反应就是**前缀和**！

我们可以：
1. 计算前缀和数组 `sum[]`，其中 `sum[i] = nums[0] + ... + nums[i-1]`
2. 子数组 `[i, j]` 的和 = `sum[j+1] - sum[i]`

#### 第二步：暴力解法（会超时）

```go
// 暴力枚举所有长度为 k 的倍数的子数组
maxSum := math.MinInt64
for i := 0; i < n; i++ {
    for j := i; j < n; j++ {
        length := j - i + 1
        if length % k == 0 {
            maxSum = max(maxSum, sum[j+1] - sum[i])
        }
    }
}
```

**问题**：时间复杂度 O(n²)，当 n = 2×10⁵ 时会超时。

#### 第三步：关键优化 - 按模分组

**核心观察**：
- 如果子数组长度 `j - i + 1` 能被 k 整除
- 即 `(j+1) - i ≡ 0 (mod k)`
- 即 `(j+1) % k == i % k`

**优化思路**：
- 将所有位置按 `index % k` 分成 k 组
- 对于位置 j，只需要在 `(j+1) % k` 这一组中，找前缀和最小的位置 i
- 这样 `sum[j+1] - sum[i]` 就是以 j 结尾的最大子数组和

### 算法流程

```
1. 初始化：
   - 创建数组 minSum[k]，记录每组的最小前缀和
   - 初始值都设为 0（表示空数组）
   
2. 遍历每个位置 j：
   - 计算前缀和 sum[j+1]
   - 计算当前位置的组号 mod = (j+1) % k
   - 用 sum[j+1] - minSum[mod] 更新答案
   - 更新 minSum[mod] = min(minSum[mod], sum[j+1])
   
3. 返回答案
```

### 代码实现

```go
func maxSubarraySum(nums []int, k int) int64 {
    n := len(nums)
    
    // 计算前缀和
    sum := make([]int64, n+1)
    for i := 0; i < n; i++ {
        sum[i+1] = sum[i] + int64(nums[i])
    }
    
    // 按模分组，记录每组的最小前缀和
    minSum := make([]int64, k)
    for i := range minSum {
        minSum[i] = math.MaxInt64
    }
    minSum[0] = 0  // 空数组的前缀和为 0
    
    ans := int64(math.MinInt64)
    
    for j := 0; j < n; j++ {
        mod := (j + 1) % k
        // 用当前位置减去同组的最小前缀和
        if minSum[mod] != math.MaxInt64 {
            ans = max(ans, sum[j+1] - minSum[mod])
        }
        // 更新该组的最小前缀和
        minSum[mod] = min(minSum[mod], sum[j+1])
    }
    
    return ans
}
```

### 复杂度分析

- **时间复杂度**：O(n)，只需遍历一次数组
- **空间复杂度**：O(n + k)，前缀和数组 O(n)，分组数组 O(k)

## 三、前缀和套路总结

### 适用场景

✅ 频繁查询区间和  
✅ 子数组和相关问题  
✅ 需要快速计算连续元素之和

### 常见变形

1. **二维前缀和**：处理矩阵区间和
2. **差分数组**：前缀和的逆运算，用于区间修改
3. **前缀和 + 哈希表**：处理"和为 k 的子数组"
4. **前缀和 + 取模**：本题的核心技巧

### 解题步骤

1. **识别**：看到"子数组和"就想前缀和
2. **暴力**：先写出 O(n²) 的暴力解法
3. **优化**：分析如何利用前缀和的单调性或其他性质降低复杂度
4. **实现**：注意边界条件（空数组、初始值等）

## 四、举一反三

类似题目：
- LeetCode 560：和为 K 的子数组（前缀和 + 哈希表）
- LeetCode 974：和可被 K 整除的子数组（前缀和 + 取模）
- LeetCode 1590：使数组和能被 P 整除（前缀和 + 取模 + 哈希表）

掌握前缀和这个基础工具，配合不同的数据结构（哈希表、单调队列等），可以解决一大类子数组问题！
# 3075. 幸福值最大化的选择方案

## 题目分析

这是一道经典的**贪心算法**题目。核心问题是：在每轮选择后，所有未被选中的孩子幸福值都会减1，我们应该按什么顺序选择k个孩子，才能使总幸福值最大？

## 解题思路

### 1. 为什么贪心策略是正确的？

**关键观察**：每一轮选择后，所有未选中的孩子幸福值都**同时减少1**。这意味着：
- 第1次选择（第0轮）：选中的孩子贡献原始幸福值
- 第2次选择（第1轮）：选中的孩子贡献 `原始幸福值 - 1`
- 第3次选择（第2轮）：选中的孩子贡献 `原始幸福值 - 2`
- ...
- 第k次选择（第k-1轮）：选中的孩子贡献 `原始幸福值 - (k-1)`

由于每个孩子的幸福值**减少速度相同**（每轮减1），因此：
- **初始幸福值越大的孩子，在任意时刻的幸福值都越大**
- 所以应该**优先选择初始幸福值最大的孩子**

### 2. 算法步骤

1. **降序排序**：将 `happiness` 数组按从大到小排序
2. **依次选择前k个**：
   - 第 `i` 个被选中的孩子（i从0开始），在第 `i` 轮被选择
   - 此时已经经历了 `i` 轮减少，幸福值为 `happiness[i] - i`
3. **处理负数**：如果 `happiness[i] - i < 0`，则贡献为0（题目要求幸福值不能为负）

### 3. 示例演算

以**示例1**为例：`happiness = [1,2,3], k = 2`

**排序后**：`[3, 2, 1]`

**选择过程**：
- 第0轮：选择 `happiness[0] = 3`，贡献 `3 - 0 = 3`
- 第1轮：选择 `happiness[1] = 2`，贡献 `2 - 1 = 1`

**总幸福值**：`3 + 1 = 4` ✅

### 4. 复杂度分析

- **时间复杂度**：O(n log n)
  - 排序：O(n log n)
  - 遍历选择：O(k)
  - 总体：O(n log n)
  
- **空间复杂度**：O(1)
  - 原地排序，不需要额外空间

## 代码实现

```go
package maximizehappinessofselectedchildren

import "slices"

func maximumHappinessSum(happiness []int, k int) int64 {
    // 降序排序，优先选择幸福值最大的孩子
    slices.Sort(happiness)
    slices.Reverse(happiness)
    
    var total int64
    // 第i个被选中的孩子，经历了i轮减少，幸福值为 happiness[i] - i
    for i := 0; i < k; i++ {
        // 幸福值不能为负数，如果减少后小于0则贡献0
        total += max(int64(happiness[i]-i), 0)
    }
    return total
}
```

## 关键要点

1. ✅ **贪心选择**：因为所有孩子幸福值同时减少，所以优先选大的一定最优
2. ✅ **索引即轮数**：第i个被选中的孩子在第i轮被选，已经减少了i次
3. ✅ **边界处理**：使用 `max(value, 0)` 确保幸福值不为负

## 标签
`贪心` `排序` `数组` `简单题`

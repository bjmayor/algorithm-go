package main

import "fmt"

func isValidSudoku(board [][]byte) bool {

	m3 := make([][]byte, 0, 9)
	for i := 0; i < 9; i++ {
		m3 = append(m3, make([]byte,9,9))
	}
	for i := 0; i < 9; i++ {
		m1 := make([]byte,9,9)
		m2 := make([]byte,9,9)
		for j := 0; j < 9; j++ {
			if board[i][j] != '.' {
				v1 := board[i][j] - '1';
				if   m1[v1] == 1 {
					return false
				} else {
					m1[v1] = 1
				}
				idx := i/3*3 + j/3
				if m3[idx][v1] == 1 {
					return false
				} else {
					m3[idx][v1] = 1
				}
			}
			if board[j][i] != '.' {
				v2 := board[j][i] - '1'
				if 1 == m2[v2] {
					return false
				} else {
					m2[v2] = 1
				}
			}

		}
	}

	return true
}

func main() {
	//board := [][]byte{
	//	[]byte{'5','3','.','.','7','.','.','.','.'},
	//	[]byte{'6','.','.','1','9','5','.','.','.'},
	//	[]byte{'.','9','8','.','.','.','.','6','.'},
	//	[]byte{'8','.','.','.','6','.','.','.','3'},
	//	[]byte{'4','.','.','8','.','3','.','.','1'},
	//	[]byte{'7','.','.','.','2','.','.','.','6'},
	//	[]byte{'.','6','.','.','.','.','2','8','.'},
	//	[]byte{'.','.','.','4','1','9','.','.','5'},
	//	[]byte{'.','.','.','.','8','.','.','7','9'},
	//}

	board2 := [][]byte{
		[]byte{'.', '.', '.', '.', '.', '.', '.', '.', '.'},
		[]byte{'4', '.', '.', '.', '.', '.', '.', '.', '.'},
		[]byte{'.', '.', '.', '.', '.', '.', '6', '.', '.'},
		[]byte{'.', '.', '.', '3', '8', '.', '.', '.', '.'},
		[]byte{'.', '5', '.', '.', '.', '6', '.', '.', '1'},
		[]byte{'8', '.', '.', '.', '.', '.', '.', '6', '.'},
		[]byte{'.', '.', '.', '.', '.', '.', '.', '.', '.'},
		[]byte{'.', '.', '7', '.', '9', '.', '.', '.', '.'},
		[]byte{'.', '.', '.', '6', '.', '.', '.', '.', '.'},
	}
	//fmt.Println(isValidSudoku(board))
	fmt.Println(isValidSudoku(board2))
}

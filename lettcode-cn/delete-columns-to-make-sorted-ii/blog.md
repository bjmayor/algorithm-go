## 题意回顾
给定若干长度相同的字符串，要求删除最少的列，使得列删除后按字典序比较时整体非严格递增。题目与上一题类似，但难点在于不能简单地逐列比较整串，因为某些相邻行在当前列之前已经确定顺序，剩下的列无需继续判断；而仍然相等的相邻行必须继续检查后续列。

## 关键思路
1. 逐列扫描，从第 0 列到最后一列。
2. 使用 `sorted[i]` 表示 `strs[i]` 与 `strs[i+1]` 是否已经确定 `strs[i] < strs[i+1]`。一旦确定，在后续列中就无需再比较这一对。
3. 扫描当前列时，只比较尚未确定顺序的相邻对：
	- 一旦发现 `strs[i][col] > strs[i+1][col]`，说明这一列必须删除，直接累计答案并跳过该列。
	- 如果 `strs[i][col] < strs[i+1][col]`，说明这一列帮助这对行确定了顺序，标记 `sorted[i] = true`。
4. 未被删除的列继续向后处理，直到所有列遍历完。答案即被删除的列数。

## 举例
以 `{"ca","bb","ac"}` 为例：
1. 第 0 列得到 `c > b`，这一列必须删除，`ans = 1`。
2. 第 1 列比较尚未确定顺序的相邻对：`a < b`，`b < c`，两对都被标记为已排序，且没有冲突，因此无需删除。
3. 所有列扫描结束，最终答案为 1。

## 小结
本题的核心在于“局部排序状态”——每对相邻行是否已经被之前的列严格区分。一旦能把需要继续比较的行对限制在仍未区分的部分，就能在 O(n*m) 内完成判断，避免重复拼接字符串或回溯。整体逻辑清晰、实现简单。*** End Patch


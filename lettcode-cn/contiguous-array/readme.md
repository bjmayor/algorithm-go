https://leetcode-cn.com/problems/contiguous-array/

给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。


示例 1:

输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。


暴力求解：
遍历i->j, 和=j-i+1, 表示符合要求。 取符合要求的最大值即可。
提交超时。本地运行1.4秒。

感觉和 https://leetcode-cn.com/problems/continuous-subarray-sum/ 相似。也可以考虑前缀和的思路。
考虑一组数据。[0,1,0,1,0,0,1,1,1,0,0]
0,i 的和 与 0,j 的和 的差值 如果如果满足 sum(0,j)-sum(0,i)= sum(i,j) == (j-i+1) * 2 。
说明i,j 满足需求。然后取最大值即可。
这里有个问题。sum(0,j) 是当前累计和。j 是当前需要考虑的元素。。 i和sum(0,i) 不好弄。因为计算过程需要用到i, 没法直接hash。这条思路不通。去遍历i的话，又回到nxn的复杂度。
关键问题是 有个i存在。 (j-i+1) * 2 , 有没有办法去掉这个计算？？？
考虑把0修改成-1, 那么就变成了满足 sum(0,j)-sum(0,i) = 0。做法和昨天那个就一样了。


标色法呢？遍历所有的1，看他的左右是不是是0，如果有1个是0，就把这个1和0赋值为-1， 最后再遍历一遍统计连续的-1的个数。
有个问题是左结合还是右结合的问题。这样算法复杂度又提上去了。

最优解试下dp求解。dp[n]表示以第n个元素结尾的最大连续子数组的长度。
在已有dp[1]->dp[n]的解的情况下。如果求解dp[n+1]
判断dp[n]>0 ，是的话，有解。在判断dp[n-dp[n]] + nums[n+1] 是否=1， 如果=1， 说明符合要求。则dp[n+1] = dp[n]+2, 如果不等于1, 说明。无法和已有解连接。再尝试nums[n]+nums[n+1] 是否有解。
否则dp[n+1]= 0。
如果dp[n]=0, 说明无解，nums[n]+nums[n+1] 是否=1， 如果=1， 说明符合要求，则dp[n+1]=2=dp[n]+2, 否则dp[n+1]= 0 
此路不通：局部最优解不是全局最优解。

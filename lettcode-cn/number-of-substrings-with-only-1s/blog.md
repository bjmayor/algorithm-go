 # 1513. 仅含 1 的子串数 - 解题分析

## 算法思想

这个题的核心思想是**局部解组成全局解**的分治思想。我们将字符串按照 '0' 进行分割，每一段连续的 '1' 都是一个独立的子问题，然后将各段的结果相加得到最终答案。

## 关键数学公式

对于 n 个连续的 '1'，包含的子串个数为：
```
count = n(n+1)/2 = 1 + 2 + 3 + ... + n
```

**为什么是等差数列？**
- 长度为 1 的子串：n 个
- 长度为 2 的子串：n-1 个  
- 长度为 3 的子串：n-2 个
- ...
- 长度为 n 的子串：1 个

总和就是 1 + 2 + 3 + ... + n = n(n+1)/2

## 解题步骤

1. 遍历字符串，统计连续 '1' 的长度
2. 遇到 '0' 时，将当前连续 '1' 的长度代入公式计算子串数
3. 累加所有段的结果
4. 处理字符串末尾可能存在的连续 '1'

## 时间复杂度

- 时间复杂度：O(n)，只需要一次遍历
- 空间复杂度：O(1)，只使用常数空间

## 边界情况

- 全为 '1' 的字符串
- 全为 '0' 的字符串  
- 字符串首尾的处理
- 单个字符的字符串

## Go 代码实现

```go
func countSubstrings(s string) int {
    const MOD = 1000000007
    result := 0
    count := 0
    
    for _, char := range s {
        if char == '1' {
            count++
        } else {
            result = (result + count*(count+1)/2) % MOD
            count = 0
        }
    }
    
    // 处理字符串末尾可能存在的连续 '1'
    result = (result + count*(count+1)/2) % MOD
    
    return result
}
```

## 总结

这道题目看似简单，但很好地体现了将复杂问题分解为简单子问题的思想。通过数学公式优化，避免了暴力枚举所有子串的低效做法。
 
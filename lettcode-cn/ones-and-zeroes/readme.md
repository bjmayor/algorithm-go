https://leetcode-cn.com/problems/ones-and-zeroes/

暴力求解肯定能解决。但是估计也是超时。但是可以作为测试基准。
为避免重复计算。可以先把原始的strs做个简单的统计。统计每个元素中1还有多少个，0有多少个。[2]int存下来即可。
暴力求解的思路是考虑第i个元素在里面和不在里面2种可能。时间复杂度是2的n次方。

有点像背包问题。有N件物品和一个容量为V 背包。第i件物品的费用是w[i]，价值是v[i]，求将哪些物品装入背包可使价值总和最大。
解决思路是动态规划。
定义状态f[i][j] 为前i件物品恰放入一个容量为j的背包可以获得的最大价值。
状态转移方程为：
f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i])
f[i-1][j]  表示物品i不放入。 f[i-1][j-w[i]]+v[i] 表示物品i放入。


把当前问题的strs[i]当成物品。每个物品的价值是1。空间是个向量<m,n>, 问题就转化成了背包问题。提交解决问题。但是只击败了5%的用户，说明有优化空间。


 在动态规划中，如果第i个状态只与第i-1个状态有关，而不与其他的例如第i - k(0 < k < i)个状态有关，那么意味着此时
 在空间上有优化的空间，我们可以采用滚动数组或者从后往前的方式填表来代替开辟更高维度的数组。需要注意的是需要逆序遍历空间。因为
 f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i]), 在省略i时，为了保证f[j-w[i]] 是上一轮的结果就必须逆序，否则其值是这一轮的，与公式不符。
 这个场景恰好满足。。
 优化完击败67%的用户。对比了官方求解也是这个方法。不过发现排名第一的解法不一样。执行时间少了一半, 解题思路其实还是动态规划。

 
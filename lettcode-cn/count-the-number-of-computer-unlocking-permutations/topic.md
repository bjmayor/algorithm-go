# 3577. 统计计算机解锁顺序排列数

给你一个长度为 n 的数组 `complexity`。

房间里有 n 台上锁的计算机，编号为 0 到 n - 1，每台计算机的密码复杂度为 `complexity[i]`（唯一标识该台计算机的密码强度）。编号为 0 的计算机的密码已经被解锁并作为根节点（root）。

其他所有计算机必须通过它或其他已被解锁的计算机来解锁，规则如下：

- 可以使用编号为 `j` 的计算机的密码解锁编号为 `i` 的计算机，前提是 `j < i` 且 `complexity[j] < complexity[i]`。
- 要解锁 `i`，必须事先解锁至少一台满足上述条件的 `j`（即编号比 `i` 小且复杂度更小的已解锁计算机）。

现在考虑所有的 `n` 个编号的排列（即 `[0, 1, 2, ..., n - 1]` 的全排列）。当一个排列代表一种从编号 0 开始（0 初始已解锁）解锁所有计算机的有效顺序时，我们称该排列为有效排列。

请返回有效排列的数量。由于答案可能很大，请将结果对 10^9 + 7 取模后返回。

注意：
- 题目声明“编号为 0 的计算机的密码已解锁”，这里强调“已解锁”的是标签为 0 的计算机，而不是“排列中第一个位置的计算机”。也就是说：计算机 0 在一开始就已被解锁，但在排列中它可以出现在任意位置，排列的含义是“解锁顺序”。

示例 1：

输入：

```text
complexity = [1, 2, 3]
```

输出：

```text
2
```

解释：

有效排列包括 [0,1,2] 和 [0,2,1]。

示例 2：

输入：

```text
complexity = [3,3,3,4,4,4]
```

输出：

```text
0
```

解释：

不存在可以解锁所有计算机的排列。

提示：

- 2 <= complexity.length <= 10^5
- 1 <= complexity[i] <= 10^9

提示与思路（可选）：

- 如果存在 i>0 满足 complexity[i] <= complexity[0] 且 complexity[i]==complexity[0]，那么有些计算机永远无法被解锁（因为条件要求 j < i 且 complexity[j] < complexity[i]，而 0 是最小索引且复杂度不小于等于这些等于或更小值的其他项），这样可能导致答案为 0。
- 若 complexity[0] 是所有元素中且唯一的最小值，则对于任意 i>0，总能用编号 0 解锁 i；此时剩余 n-1 个元素的相对排列均可行，答案为 (n-1)!。（注意：具体情况需结合题意与约束检验）

---

提示1:
确保索引 0 处的元素具有唯一的最小复杂度（没有其他元素能与其值匹配）
提示2:
将索引 0 固定为解锁顺序中的第一个。
提示3:
随后，索引 1 到 n-1 可以任意排列，从而产生 factorial(n-1) 种可能的顺序。

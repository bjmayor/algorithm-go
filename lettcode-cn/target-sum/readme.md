https://leetcode-cn.com/problems/target-sum/

1. 最简单思路就是递归。
第n个元素放+的个数(前n-1的和更新为target-nums[n]) + 放-号的个数(前n-1的和更新为target+nums[n])。
复杂度有点高。2的n次方。
提交下，竟然通过了。只是运行时间击败28%的用户，内存击败95%的用户。说明有更好的方法。

2. 如果直接遍历，并存下和呢？
因为前n个数的和的组合数< 2的n次方，所以最终的时间复杂度会小于递归的2的n次方。但是内存会消耗的更好。
实际提交可以通过。运行时间击败43%的用户，内存击败7.47%的用户。说明有更好的方法。

3. 
观察到题目的特殊性，0 <= sum(nums[i]) <= 1000。 0 <= nums[i] <= 1000
原题可以转化为:找到nums一个正子集和一个负子集，使得总和等于target
我们假设P是正子集，N是负子集 例如： 假设nums = [1, 2, 3, 4, 5]，target = 3，一个可能的解决方案是+1-2+3-4+5 = 3 这里正子集P = [1, 3, 5]和负子集N = [2, 4]

那么让我们看看如何将其转换为子集求和问题：
                  sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)
因此，原来的问题已转化为一个求子集的和问题： 找到nums的一个子集 P，使得sum(P) = (target + sum(nums)) / 2
这就可以用dp求解了。
定义dp[i][j] 为 前i个元素和为j的个数。
转移方程为:
dp[i+1][j] = dp[i][j]+dp[i][j-nums[i]] // dp[i][j]表示第i+1个元素用减号。dp[i][j-nums[i]]表示第i+1个元素用＋号。
又dp[i+1] 只依赖于dp[i], 故可以用滚动数组的方式。
提交通过，运行时间击败100%的用户，内存击败53%的用户。
# LeetCode 1930: 长度为 3 的不同回文子序列 - 解题思路与代码实现

大家好！今天我们来聊聊 LeetCode 的第 1930 题：“长度为 3 的不同回文子序列”。这道题中等难度，但很有趣，能帮我们练习字符串处理和子序列的概念。如果你刚学编程不久（比如大一新生），别担心，我会用最简单的语言一步步解释。

## 什么是回文子序列？

先来复习一下基本概念：
- **子序列**：从原字符串中删除一些字符（或不删），剩下的字符按原顺序组成的新字符串。比如，字符串 "abc" 的子序列有 "a"、"b"、"c"、"ab"、"ac"、"bc"、"abc"。
- **回文**：正着读和反着读一样。比如 "aba" 是回文，"abc" 不是。

这道题要找的是**长度正好为 3 的回文子序列**，而且要统计不同的个数。注意：就算有多种方式组成同一个子序列，也只算一次。

## 问题描述

给你一个字符串 `s`，只包含小写字母，长度从 3 到 10^5（10 万）。返回 `s` 中有多少个不同的长度为 3 的回文子序列。

示例：
- 输入: "aabca"，输出: 3（分别是 "aba"、"aaa"、"aca"）
- 输入: "adc"，输出: 0（没有长度 3 的回文子序列）

## 我的思路：从暴力到优化

### 原始暴力思路（简单但慢）

一开始我想：对于每个可能的回文子序列，手动找出来，用 set 去重，最后统计个数。

具体怎么找？对于字符串 "aabca"：
- 起点选第一个 'a'（位置 0），然后找后面的 'a' 作为终点（位置 4）。
- 中间位置 1、2、3 有字符 'a'、'b'、'c'。
- 不同的中间字符有 'a'、'b'、'c'，所以可以组成 "aba"、"aaa"、"aca"。

对每个字符重复这个过程。但如果字符串很长，这个方法太慢了（时间复杂度 O(n^2)，n 是字符串长度）。对于 n=10^5，会超时。

### 为什么需要优化？观察规律

暴力法超时，怎么办？我们仔细想想：长度为 3 的回文子序列，一定是 `x y x` 的形式，两端是同一个字符 `x`，中间是 `y`。

而且，`x` 只能是 a-z 中的字母（26 个），`y` 也是。

提示说“最大数量是 26*26”，因为理论上最多 26 种 `x` 和 26 种 `y`，但实际取决于字符串。

所以，我们可以固定 `x` 为 a-z 中的每个字母，然后对于每个 `x`，找到它在字符串中的最左位置 `left` 和最右位置 `right`。

如果 `right > left + 1`（确保至少有一个中间字符），那么中间（`left+1` 到 `right-1`）的不同字符 `y` 的数量，就是该 `x` 贡献的回文子序列数。

这样，我们遍历 26 个字母，每个字母处理字符串一次，总时间 O(26 * n) ≈ O(n)，高效！

### 优化思路（高效版本）

关键步骤：

- 对于每个字符 `x`（a 到 z），遍历字符串找到 `left`（第一次出现）和 `right`（最后一次出现）。

- 如果 `right > left + 1`，则扫描中间部分，用 set 统计不同字符的数量，加到总计数。

这个方法避免了暴力搜索，直接利用回文结构。

## 代码实现（Go 语言）

```go
func countPalindromicSubsequence(s string) int {
	count := 0
	for c := 'a'; c <= 'z'; c++ {
		left := -1
		right := -1
		for i, ch := range s {
			if ch == c {
				if left == -1 {
					left = i
				}
				right = i
			}
		}
		if left != -1 && right > left+1 {
			seen := make(map[byte]bool)
			for i := left + 1; i < right; i++ {
				seen[s[i]] = true
			}
			count += len(seen)
		}
	}
	return count
}
```

## 为什么这个代码对吗？

- 对于 "aabca"：
  - 'a' 的 left=0, right=4，中间 'a','b','c'，不同字符 3 个。
  - 其他字符没有两个以上，跳过。
  - 总计 3，正确！

- 对于 "adc"：没有字符有 left < right，输出 0。

- 对于 "bbcbaba"：类似计算，每个字符的中间字符种类数相加。

## 时间和空间复杂度

- **时间**：O(n)，n 是字符串长度。遍历两次字符串（记录位置和扫描中间），26 是常数。
- **空间**：O(1)，除了 map（最坏 26 个字符），其他固定大小。

## 总结

这道题其实就是一道观察题，没啥特别的算法套路。主要靠观察规律：长度 3 的回文子序列一定是 `x y x` 形式，两端固定为同一个字符 `x`，中间统计不同 `y` 的数量。

通过遍历 26 个字母，找到每个 `x` 的最左和最右位置，然后统计中间字符种类，就能高效解决。时间 O(n)，空间 O(1)。

关键是理解子序列的性质和回文定义，多做这类题能培养观察力。如果你刚学编程，多练习字符串和子序列问题，会进步很快！

（本文基于 LeetCode 1930，代码已在本地测试通过。）

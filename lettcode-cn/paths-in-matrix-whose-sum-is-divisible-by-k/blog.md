# 动态规划解题套路详解 - 以 LeetCode 2435 为例

动态规划（Dynamic Programming, DP）往往是算法面试中的难点。很多同学面对 DP 题目时，往往感到无从下手。其实，DP 问题是有迹可循的。本文将总结一套通用的动态规划解题套路，并以 LeetCode 2435 题为例，演示如何应用这套方法。

## 一、 动态规划解题套路

### 1. 如何识别动态规划问题？

通常，如果一个问题具备以下特征，可以考虑使用动态规划：

*   **计数问题**：求有多少种方案（例如：有多少种路径）。
*   **最值问题**：求最大值、最小值（例如：最长公共子序列、最小路径和）。
*   **存在性问题**：判断是否存在某种方案（例如：能否凑出某个金额）。

此外，DP 问题通常满足三个性质：
*   **最优子结构**：大问题的最优解包含小问题的最优解。
*   **重叠子问题**：子问题会被重复计算（DP 通过记录状态避免重复计算）。
*   **无后效性**：当前状态一旦确定，就不受未来决策的影响。

### 2. 如何推导状态转移方程？

推导状态转移方程通常遵循“四步走”：

1.  **定义状态 (State)**：
    *   思考在这个问题中，哪些变量在变化？这些变化的变量就构成了状态。
    *   状态的定义决定了 DP 数组的维度。

2.  **确定选择 (Choice)**：
    *   在每个状态下，我们可以做什么选择？
    *   选择决定了状态如何转移。

3.  **明确 base case (Base Case)**：
    *   最简单的子问题是什么？
    *   Base case 是递归的终止条件，也是 DP 数组的初始化值。

4.  **写出状态转移方程 (Transition)**：
    *   结合“选择”，将当前状态与子状态联系起来。
    *   `dp[当前] = 聚合(dp[来源1], dp[来源2], ...)`。

---

## 二、 案例实战：LeetCode 2435. 矩阵中和能被 K 整除的路径

### 1. 题目描述

给你一个 `m x n` 的整数矩阵 `grid` 和一个整数 `k`。从起点 `(0, 0)` 出发，每一步只能往 **下** 或者往 **右**，到达终点 `(m - 1, n - 1)`。求路径上所有格子之和能被 `k` 整除的路径数目。

### 2. 套路应用

我们按照上面的“四步走”来分析这道题。

#### 第一步：定义状态

*   **变量分析**：我们需要知道当前走到了哪个格子 `(i, j)`。此外，题目要求路径和能被 `k` 整除，这意味着我们不能只记录路径和（因为路径和可能很大），而是需要记录路径和对 `k` 取模后的 **余数**。
*   **状态定义**：`dp[i][j][rem]`
    *   `i`, `j`：当前网格坐标。
    *   `rem`：从起点到 `(i, j)` 的路径和对 `k` 取模的余数 (`0 <= rem < k`)。
    *   `dp[i][j][rem]` 的值：满足该余数条件的路径数量。

#### 第二步：确定选择

*   在 `(i, j)` 位置，我们只能从 **上方** `(i-1, j)` 或 **左方** `(i, j-1)` 走过来。
*   这就是我们的“选择”。

#### 第三步：明确 Base Case

*   起点是 `(0, 0)`。
*   在起点，路径和就是 `grid[0][0]`。
*   所以初始状态为：`dp[0][0][grid[0][0] % k] = 1`。

#### 第四步：写出状态转移方程

假设我们从上方 `(i-1, j)` 走到 `(i, j)`：
*   之前的余数是 `rem`。
*   当前的数值是 `grid[i][j]`。
*   新的余数 `newRem = (rem + grid[i][j]) % k`。

同理，从左方 `(i, j-1)` 走过来也是一样。

因此，对于每个余数 `rem`，我们可以更新 `newRem` 的状态：
`dp[i][j][newRem] = (dp[i-1][j][rem] + dp[i][j-1][rem]) % mod`

### 3. 代码实现 (Go)

```go
func numberOfPaths(grid [][]int, k int) int {
    m, n := len(grid), len(grid[0])
    mod := int(1e9 + 7)
    
    // dp[i][j][rem]
    // 初始化三维切片
    dp := make([][][]int, m)
    for i := range dp {
        dp[i] = make([][]int, n)
        for j := range dp[i] {
            dp[i][j] = make([]int, k)
        }
    }

    // Base Case: 初始化起点
    dp[0][0][grid[0][0]%k] = 1

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            // 遍历上一步所有可能的余数状态
            for rem := 0; rem < k; rem++ {
                // 当前格子的值
                val := grid[i][j]
                // 计算新的余数
                newRem := (rem + val) % k
                
                // 状态转移：从上方转移
                if i > 0 {
                    dp[i][j][newRem] = (dp[i][j][newRem] + dp[i-1][j][rem]) % mod
                }
                // 状态转移：从左方转移
                if j > 0 {
                    dp[i][j][newRem] = (dp[i][j][newRem] + dp[i][j-1][rem]) % mod
                }
            }
        }
    }

    // 最终答案：到达右下角，且余数为 0 的路径数
    return dp[m-1][n-1][0]
}
```

### 4. 复杂度分析

*   **时间复杂度**：`O(m * n * k)`。我们需要遍历网格的每个位置，并且对于每个位置，都需要遍历 `k` 个可能的余数状态。
*   **空间复杂度**：`O(m * n * k)`。用于存储 DP 数组。

## 三、 总结

通过这道题，我们可以看到，动态规划并没有那么神秘。只要我们按照 **状态 -> 选择 -> Base Case -> 转移方程** 的套路去思考，很多看似复杂的问题都能迎刃而解。关键在于准确地定义“状态”，找到那个变化的量。